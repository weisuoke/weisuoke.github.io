(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{307:function(e,a,t){"use strict";t.r(a);var r=t(2),_=Object(r.a)({},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"http2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2","aria-hidden":"true"}},[e._v("#")]),e._v(" HTTP2")]),e._v(" "),t("p",[e._v("HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。")]),e._v(" "),t("p",[e._v("在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。")]),e._v(" "),t("p",[e._v("在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。")]),e._v(" "),t("h3",{attrs:{id:"_1-二进制传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-二进制传输","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 二进制传输")]),e._v(" "),t("p",[e._v("HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。")]),e._v(" "),t("h3",{attrs:{id:"_2-多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-多路复用","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 多路复用")]),e._v(" "),t("p",[e._v("在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。")]),e._v(" "),t("p",[e._v("帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。")]),e._v(" "),t("p",[e._v("多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。")]),e._v(" "),t("h3",{attrs:{id:"_3-header-压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-header-压缩","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. Header 压缩")]),e._v(" "),t("p",[e._v("在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。")]),e._v(" "),t("p",[e._v("在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。")]),e._v(" "),t("h3",{attrs:{id:"_4-服务端-push"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务端-push","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 服务端 Push")]),e._v(" "),t("p",[e._v("在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。")]),e._v(" "),t("p",[e._v("可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。")])])},[],!1,null,null,null);a.default=_.exports}}]);