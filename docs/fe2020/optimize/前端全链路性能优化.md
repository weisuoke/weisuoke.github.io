# 极客时间-JavaScript 全链路性能优化

[[TOC]]

## 02 内容综述

- 静态资源优化
- 页面渲染架构设计及方案选型
- 原生 App 优化方案
- 服务端与网络优化
- 研发开发流程优化
- 全链路质量监控体系建设

## 03. 图片优化：如何为不同格式选择合适的应用场景？

**JPEG (Joint Photographic Experts Group)**

- 联合图像专家小组是一种针对彩色照片而广泛使用的有损压缩图形格式。
- 介绍:栅格图形。常用文件扩展名为.jpg,也有 jpeg、jpe。JPEG 在互联网上常被应用于存储和传输照片。
- 不适合:线条图形和文字、图标图形，因为它的压缩算法不太这些类型的图形;并且不支持透明度。
- 非常适合:颜色丰富的照片、彩色图大焦点图、通栏 banner 图;结构不规则的图形。

**PNG ( Portable Network Graphics )**

- 便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Apha 通道等特性。
- 介绍：栅格图形。PNG 最初是作为替代 GlF 来设计的，能够显示 256 色，文件比 JPEG 或者 GlF 大，但是 PNG 非常好的保留了图像质量。支持 Apha 通道的半透明和透明特性。最高支持 24 位彩色图像（PNG-24) 和 8 位灰度图像（PNG-8)。
- 不适合：由于是无损存储，彩色图像体积太大，所以不太适合。
- 非常适合：纯色、透明、线条绘图，图标；边缘清晰、有大块相同颜色区域；颜色数较少但需要半透明。

**GIF (Graphics Interchange Format）**

- 图像互換格式是一种位图图形文件格式，以 8 位色（即 256 种颜色）重现真彩色的图像，采用 LZW 压缩算法进行编码。
- 介绍：栅格图形。支持 256 色；仅支持完全透明和完全不透明；如果需要比较通用的动画，GIF 是唯一选择。
- 不适合：每个像素只有 8 比特，不适合存储彩色图片。
- 非常适合：动画，图标。

**Webp**

- Webp 是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活。由 Google 在购买 On2 Technologies 后发展出来，以 BSD 授权条款发布。
- 介绍：优秀算法能同时保证一定程序上的图像质量和比较小的体积；可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。无损的 Webp 比 PNG 小 26%，有损的 Webp 比 JPEG 小 25-34%，比 GF 有更好的动画。
- 不适合：最多处理 256 色，不适合于彩色图片。
- 非常适合：适用于图形和半透明图像。

## 04-图⽚优化：怎样让图片加载得更快？

### 4.1 **用工具进行图片压缩**

**压缩 png**

- node-pngquant-native
- 跨平台，压缩比高，压缩 png24 非常好。说明文档
- https://www.npmjs.com/package/node-pngquant-native 安装方法
- npm install node-pngquant-native

![-w999](http://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/2020/03/09/15837620323305.jpg)

**压缩 jpg**

- Jpegtran

- 跨平台，有 Linux、Mac、Windows 的解决方案
- 官网：htp: // jpegclub.org/ jpegtran/
- 安装方法：npm install -g jpegtran

- 使用方法
  - jpegtran -copy none -optimize -outfile out.jpg in.jpg

**压缩 gif**

- Gifsicle：通过改变每帧比例，减小 gif 文件大小，同时可以使用透明来达到更小的文件大小，目前公认的解决方案。

- 安装

  - http://www.lcdf.org/gifsiclel

- 使用方式
  - 优化级别设置为不小于 2,1 的话基本不压缩 `gifsicle --optimize=3 -o out.gif in.gif`
  - 将透明部分截去 `gifsicle --optimize=3 --crop-transparency -o out.gif in.gif`

### 4.2 图片尺寸随网络环境变化

- 不同网络环境(Wifi/46/3G)下,加载不同尺寸和像素的图片,通过在图片 URL 后缀加不同参数改变。

- http://img13.360buyimg.com/n1/s100x100ifs/t2443/71/12538811251/470889/c2ec38b3/570f3438N81a4b62c.jpg

### 4.3 响应式图片

- Javascript 绑定事件检测窗口大小

- CSS 媒体查询

```css
@media screen and (max-width: 640px) {
  my_image {
    width: 640px;
  }
}
```

- img 标签属性

```html
<img
  srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x"
  src="img-960w.jpg"
  alt="img"
/>
<!-- (x 描述符：表示图像的设备像素比） -->
```

### 4.4 逐步加載图像

- 使用统一占位符

- 使用 LQIP

  - 低质量图像占位符（Low Quality Image Placeholders)
  - 安装：npm install lqip

  - 源码：https://github.com/zouhir/lqip-loader

- 使用 SQIP
  - 基于 SVG 的图像占位符（SVG Quality Image Placeholders）
  - 安装：npm install sqip
  - 源码：https://github.com/axe312ger/sqip

### 4.5 真的需要图片吗？

- Web Font 代替图片

- 使用 Data URI 代替图片

- 采用 Image spriting（雪碧图）

## 05. 图片优化：在服务器端进行图片自动优化的原理是什么？

### 5.1 图片服务器自动优化解密

- 名词解释

  - 图片服务器自动化优化是可以在图片 URL 链接上增加不同特殊参数，服务器自动化生成。
  - 不同格式、大小、质量的图片。

- 处理方式

  - 图片裁剪：按长边、短边、填充、拉伸等缩放。
  - 图片格式转換：支持 JPG, GIF, PNG, WebP 等，支持不同的图片压缩率。

  - 图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等。

- Al 能力：鉴黄以及智能抠图、智能排版、智能配色、智能合成等 AI 功能。

## 06. 精简 HTML 代码

- 减少 HTML 的嵌套
- 减少 DOM 节点数
- 减少无语义代码（比如：`<div class="clear"></div>`消除浮动）

- 删除 http 或者 https 如果 URL 的协议头和当前页面的协议头一致的，或者此

- URL 在多个协议头都是可用的，则可以考虑删除协议头

- 删除多余的空格、換行符、缩进和不必要的注释

- 省略冗余标签和属性

- 使用相对路径的 URL

### 6.1 文件放在合适位置

- CSS 样式文件链接尽量放在页面头部

  - CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM Tree 渲染，也会阻塞后面 JS 执行。
  - 任何 body 元素之前，可以确保在文档部分中解析了所有 CSS 样式（内联和外联），从而减少了测浏览器必须重排文档的次数。如果放置页面底部，就要等待最后一个 CSS 文件下载完成，此时会出现“白屏“，影响用户体验。

- JS 引用放在 HTML 底部
  - 防止 JS 的加载、解析、执行对阻塞页面后续元素的正常渲染。

### 6.2 增强用户体验

- 设置 favicon.ico

  - 网站如果不设置 favicon. Ico，控制台会报错，另外页面加载过程中也没有图标 loading 过程，同时也不利于记忆网站品牌，建议统一添加

- 增加首屏必要的 CSS 和 JS
  - 页面如果需要等待所的依赖的 JS 和 CSS 加载完成才显示，则在渲染过程中页面会一直显示空白，影响用户体验，建议增加首屏必要的 CSS 和 J5, 比如页面框架背景图片或者 loading 图标，内联在 HTML 页面中。这样做，首屏能快速显示出来，相对减少用户对页面加载等待过程。（比如新浪微博 M 站页面框架）

## 07. CSS 的优化应遵循哪些原则？

### 7.1 提升 CSS 渲染性能

- 谨慎使用 expensive 属性

  - 如：nth- child 伪类；position: fied 定位

- 尽量减少样式层级数

  - 如`div ul li span i {color: blue;}`

- 尽量避免使用占用过多 CUP 和内存的属性

  - 如 text-indnt: -9999X

- 尽量避免使用耗电量大的属性
  - 如 CSS3 3D transforms、CSS3 transitions、Opacity

### 7.2 合适使用 CSS 选择器

- 尽量避免使用 CSS 表达式
  - `background-color: expression ((new Date (). Gethours0) %2? #FFF": "#000")`
- 尽量避免使用通配选择器

  - `body > a { font-weight: blod;}`

- 尽量避免类正则的属性选择器
  - `*=`
  - `|=`
  - `^=`
  - `$=`

### 7.3 提升 CSS 文件加载性能

- 使用外链的 CSS
- 尽量避免使用@ import

### 7.4 精简 CSS 代码

- 使用缩写语句
- 删除不必要的零
- 删除不必要的单位，如 px
- 刪除除过多分号
- 删除空格和注释
- 尽量减少样式表的大小

### 7.5 合理使用 Web Fonts

- 将字体部署在 CDN 上
- 将字体以 base64 形式保存在 CSS 中并通过 ocalstorage 进行缓存
- Google 字体库因为某些不可抗拒原因，应该使用国内托管服务

### 7.6 CSS 动画优化

- 尽量避免同时动画
- 延迟动画初始化
- 结合 SVG

## 08. JavaScript：如何提升 JavaScript 的执行效率？

### 8.1 JS 优化总体原则

- 当需要时才优化
- 考虑可维护性

### 8.2 提升 JS 文件加载性能

加载元素的顺序 CSS 文件放在`<head>`里，JS 文件放在`<body>`里。

### 8.3 JS 变量和函数优化

- 尽量使用 id 选择器
- 尽量避免使用 eval
- JS 函数尽可能保持简洁
- 使用事件节流函数
- 使用事件委托

### 8.4 JS 动画优化

- 避免添加大量 jS 动画
- 尽量使用 CSS3 动画
- 尽量使用 Canvas 动画
- 合理使用 requestanimationframe 动画代替 settimeout、setinterval
  - requestanimationframe 可以在正确的时间进行渲染，settimeout (callback 和 setinterval (callback 无法保证 callback 回调函数的执行时机。

### 8.5 合理使用缓存

- 合理缓存 DOM 对象
- 缓存列表长度
- 使用可缓存的 Ajax？

## 09. JavaScript：如何对 JavaScript 的缓存进行优化？

### 9.1 Cookie

- 通常由浏览器存储，然后将 ookie 与每个后续请求一起发送到同一服务器。收到 HTTP 请求时，服务器可以发送带有 Cookie 的 header 头。可以给 Cookie 设置有效时间

- 应用于
  - 会话管理：登录名，购物车商品，游戏得分或服务器应要记录的其他任何内容
  - 个性化：用户首选项，主题或其他设置
  - 跟踪：记录和分析用户行为，比如埋点

### 9.2 sessionStorage

- 创建一个本地存储的键/值对应用于
- 应用于
  - 页面应用页面之间传值

### 9.3 IndexedDB

- 索引数据库
- 应用于
  - 客户端存储大量结构化数据
  - 没有网络连接的情况下使用（比如 Google Doc、石墨文档）
  - 将冗余、很少修改、但经常访问的数据，以避免随时从服务器获取数据

### 9.4 LocalStorage

- 本地存储

- 应用于
  - 缓存静态文件内容 JS/CSS(比如百度 M 站首页)
  - 缓存不常变更的 API 接口数据
  - 储存地理位置信息
  - 浏览在页面的具体位置

## 10. 如何选择合适的模块化加载方案？

### 10.1 JS 模块化加载方案和选型

- Commonjs
  - 旨在 Web 浏览器之外为 avascripts 建立模块生态系统 Node.js 模块化方案受 Commonjs
- AMD (Asynchronous Module Definition)（异步模块定义）规范
  - RequireJS 模块化加载器：基于 AMD API 实现
- CMD (Common Module Definition)（通用模块定义）规范
  - Seajs 模块化加载器：遵循 CMD API 编写
- ES6 import

![-w1080](http://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/2020/03/10/15838449336200.jpg)

## 11. 怎样才能减少浏览器的回流和重绘？

### 11.1 CSS

- 避免过多样式嵌套
- 避免使用 CSS 表达式
- 使用绝对定位，可以让动画元素脱离文档流
- 避免使用 table 布局
- 尽量不使用 float 布局
- 图片最好设置好 width 和 height
- 尽量简化浏览器不必要的任务，減少页面重新布局
- 使用 Viewport 设置屏幕缩放级别
- 避免频繁设置样式，最好把新 style 属性设置完成后, 进行一次性更改
- 避免使用引起回流/重绘的属性，最好把相应变量缓存起来

### 11.2 JS

- 最小化回流和重排
  - 为了减少回流发生次数，避免频繁或操作 DOM，可以合并多次对 DOM 修改，然后一次性批量处理。
- 控制绘制过程和绘制区域
  - 绘制过程开销比较大的属性设置应该尽量避免減少使用
  - 减少绘制区域范围

## 12. DOM 编程优化：怎样控制 DOM 大小并简化 DOM 操作？

- 控制 DOM 大小
  - 众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量 DOM 元素。想象一下，从一个上万节点的 DOM 树上，使用 querySelectorAll 或 getElementByTagName 方法查找某一个节点，是非常耗时的。另外元素绑定事件事件冒泡和事件捕获的执行也会相对耗时。
- 通常控制 DOM 大小的技巧包括
  - 合理的业务逻辑
  - 延迟加载即将呈现的内容

### 12.1 简化 DOM 操作

- 对 DOM 节点的操作统一处理后，再统一插入到 DOM Tree 中。
- 可以使用 fragment，尽量不在页面 DOM Tree 里直接操作。
- 现在流行的框架 Angular、React、Vue 都在使用虚拟 DOM 技术，通过 diff 算法简化和减少 DOM 操作。

### 13. 静态文件：有哪些常用的压缩工具？

### 13.1 静态文件压缩工具介绍

- HTML 压缩工具
  - html-minifier https://www.npmis.com/package/html-minifier
- CSS 压缩工具
  - clean-css https://ww.npmis.com/package/clean-css
- JS 压缩工具
  - uglify-js https://www.npmis.com/package/uglify-js
  - 使用方法：uglifyjs in js -o out.js

## 14. 静态文件：怎样打包才更合理？

### 14.1 静态文件打包方案

- 公共组件拆分
- 压缩： JS/CSS/图片
- 合并: JS/CSS 文件合并，CSS Sprite
- Combo: JS/CSS 文件 Combo http:/cdn.com/??a.js,b.js 内容

## 15. 静态文件：版本号更新，你应该遵循哪些策略？

### 15.1 静态文件版本号更新策略

- 缓存更新
  - CDN 或 ng 后台刷新文件路径，更新文件 header
- 头文件 name. V1-V100. J5
  - 大功能迭代每次新增一个大版本，比如由 v1 到 V2
  - 小功能迭代新增加 0.0.1 或者 0.1.0, 比如从 v1.0.0 至 v1.0.1 年末 ng 统一配置所有版本 302 至最新版

### 15.2 静态文件版本号更新策略

- 时间戳.文件 name.js

  - 以每次上线时间点做差异

- 文件 hash.文件 name.js
  - 以文件内容 hash 值做 key
  - 每次上线，文件路径不一致

## 16. 构建工具：常用的前端构建工具有哪些？如何选型？

### 16.1 前端构建工具介绍和选型建议

- Grunt
  - 最早，一个项目需要定制多个小任务和引用多个插件（质量参差不齐）
- Gulp
  - 通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少
- Webpack
  - 预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单
- FIS
- JDF (重点研究)

## 17. 打包优化：提升 webpack 打包效率的 6 个小技巧

### 17.1 Webpack 打包优化

- 定位体积大的模块

- 删除没有使用的依赖

- 生产模式进行公共依赖包抽离

- 开发模式进行 DLL & DlllReference 方式优化

![](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-11-091711.png)

## 18. 浏览器渲染：你是否清楚浏览器的渲染过程？

### 18.1 浏览器渲染过程

![](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-12-063825.png)

1. 浏览器解析 HTML，生成 DOM Tree (Parsa HTML）。
2. 浏览器解析 CSS，生成 CSSO (CSS Object Model) Tree。
3. Javascript 会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree，浏览器将 DOM Tree 和 CSSOM Tree 合成渲染树 Render Tree)

4. 布局（Layout）：根据生成的 Render Tree，进行回流，以计算每个节点的几何信息（位置、大小、字体样式等等）。
5. 绘制（Painting）：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素。
6. 展示（Display）：将像素发送给图形处理器（GPU），展示在页面上。

## 19 页面渲染：主流的页面渲染技术架构和方案有哪些？

### 19.1 页面渲染技术架构和方案总览

1. 服务端渲染

   - 后端同步渲染、同构直出、Big Pipe

2. 客户端渲染

   - Javascript 渲染：静态化、前后端分离、单页面应用
   - Web App: Angular、React、Vue 等，PMA
   - 原生 App: iOS、Android
   - Hybrid App: Phone Gap、Appcan 等
   - 跨平台开发：RN、Flutter、小程序等

## 20 后端同步渲染：JSP 是如何同步渲染出页面的？

### 20.1 同步渲染步骤（以 JSP 为例）

- 步骤 1: JSP Servlet 映射以 .jsp 结尾的 URL，当 .jsp 文件请求时，servlet 容器知道要调用哪个 Servlet。

- 步骤 2: Servlet 容器检查 Servlet 是否已被编译。

- 步骤 3: 如果未在步骤 2 中进行编译，则 Servlet 容器会将 JSP 转换为 Servlet 代码，并进行编译。
- 步骤 4: Servlet 容器将 JSP 请求转发到编译 JSP Servlet 类。
- 步骤 5: JSP Servlet 类返回并发送给客户端浏览器 HTML。

### 20.2 后端同步渲染

- 技术优点
  - 快速实现业务开发并上线
- 技术不足

  - 需要先实现业务逻辑和功能，再输出 HTML 內容给浏览器，用户需等待 HTML 页面完全加载之后オ能看到页面内容；代码耦合严重，不太好业务逻辑和页面模板；需求变更上线周期相对较长。

- 协作方式

  - 前端出静态页面，后端套页面

- 后端选型建议

  - 如果是创业初期验证阶段，或者 20 个研发人员以内的项目，为了满足业务快速验证并一天内多次上线，技术选型上使用服务端同步渲染没有任何问题，一人字就是““快”。

- 协作力器
  - jSmart
  - Velocity. Js

## 21 页面静态化：动态页面静态化要如何实施？

### 21.1 静态化

- 定义

  - 静态化是使动态化的网站生成静态 HTML 页面以供用户更好访问的技术，一般分为纯动态化和伪动态化。

- 技术优势

  - 提高了页面访问速度，降低了服务器的负担，因为访问页面时不需要每次去访问数据库。
  - 提高网站內容被搜索引擎搜索到的几率，因为搜索引擎更喜欢静态页面。
  - 网站更稳定，如果后端程序、数据库出现问题，会直接影响网站的正常访问，而静态化面有缓存，更不容易出现问题。

- 技术不足

  - 服务器存储占用问题，因为页面量级在增加，要占用大用硬盘空间。
  - 静态页面中的链接更新问题会有死链或者错误链接问题。

- 技术实现

  - 跑定时任务，将已有的动态內容进行重定，生成静态的 HTML 页面。

  - 利用模板技术，将模板引擎中模板字符替换为从数据库字段中取出来的值，同时生成 HTML 文件。

- 协作方式
  - 前端统一写好带有交互的完整静态页面。
  - 后端拆分出静态页面文件，并嵌套在后端模板文件中。
- 选型建议
  - 后端研发人员充分，又需要考虑用户体验、服务器负载的业务。

## 22 前后端分离：如何正确理解和实现前后端分离？

### 22.1 前后端分离

- 定义
  - 前后端分离是指研发人员分离、业务代码分离、后端实现业务接口，前端渲染页面。
- 技术实现
  - 后端只负责功能接口实现，提供按照约定的数据格式并封裝好的 API 接口。
  - 前端负责业务具体实现，获取到 API 接口数据后，进行页面模板拼接和渲染，独立上线。
- 协作方式

  - 前端负责实现页面前端交互，根据后端 API 接口拼装前端模板
  - 后端专注于业务功能实现和 API 接口封装。

- 技术优势
  - 团队更加专注
  - 提升了开发效率
  - 增加代码可维护性
- 技术架构

  - 后端架构：Java、PHP+ Nginx，使用微服务（比如 dubo 等）等实现业务的解耦，所有的
  - 服务使用某种协议提供不同的服务（比如 JSF 等）。
  - 前端架构：使用 Angular、React、Vue 前端框架并部署页面至 CDN。
  - 前端架构 2: 使用 Angular、React、Vue 前端框架并部署在 Node Server。

- 技术不足

  - 因为前端需要负责一大部分业务逻辑实现，和服务端同步、静态化，需要前端人力非常多。
  - 页面数据异步渲染，不利于 SEO，搜索引擎更喜欢纯静态页面。

- 选型建议
  - 这是大型互联网公司正在采用的开发模式，一句话，如果考虑用户体验，以及前端人力够用就可以积极采用。

## 23 单页面应用：什么情况下该选择单页面应用？怎样实现？

### 23.1 单页面应用极客

- 定义

  - 单页应用（single- page application，缩写 SPA）通过动态重写当前页面，来与用户交互，而非传统的从服务器重新加載整个新页面。这种方法在使用过程中不需要重新加载页面，避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。

- 技术优点
  - 不错的加载速度：用户往往感觉页面加载非常快，因为一进入页面就能看到页面元素
  - 良好的交互体验：进行局部渲染，避免不必要的页面间跳转和重复渲染
  - 前后端职责分离：前端进行页面交互逻辑，后端负责业务逻辑
  - 减轻服务器负载：服务器只处理数据接口输出，不用考虑页面模板渲染和 HTML 展示
- 技术缺点
  - 开发成本相对较高
  - 首次页面加载时间过多
  - SEO 难度比较大
- 技术实现

  - 使用 Angular、React、Vue 框架可以很好的

- 选型建议
  - 重交互页面业务核心链路场景业务

## 24 BigPipe：什么是 BigPipe？你了解它的工作原理吗？

### 24.1 BigPipe

- 定义

  - Bigpipe 通过将页面加载到称为 pagelet 的小部件中，来加快页面渲染速度，并允许浏览器在 php 服务器呈现页面的同时，一直请求页面不同区块的结构，类似一个“流”传输管道。

- 技术实现

  1. 浏览器从服务器请求页面
  2. Server 迅速呈现一个包含`<head>`标记的页面框架，以及一个包含空 div 元素的主体，这些元素充当 pagelet 的容器。由于该页面尚未完成，因此与浏览器的 HTTP 连接保持打开状态。

  3. 浏览器将开始下载 bigpipe.js 文件，然后它将开始呈现页面。

  4. PHP 服务器进程仍在执行，并且一次构建每个 Pagelet。Pagelet 完成后，其结果将在`<script> Big Pipe. Onarrive (..) </ script>`标记内发送到浏览器。
  5. 浏览器将收到的 html 代码注入正确的位置。如果小页面需要任何 CSS 资源，则也将下载这些 CSS 资源。
  6. 接收完所有的页面集之后，浏览器将开始加载那些页面集所需的所有外部 Javascript 文件。
  7. 下载 Javascript 后，浏览器将执行所有内联 Javascript。

## 25 同构直出：有哪些主流的同构直出方案？如何选择？

### 25.1 同构直出

- 定义

  - 一套代码既可以在服务端运行又可以在客户端运行，这就是同构（Universal）。

- 技术优势

  - 性能：降低首屏渲染时间
  - SE0: 服务端渲染对搜索引擎的爬取有着天然的优势
  - 兼容性：有效规避客户端兼容性问题，比如白屏
  - 代码同构：直接上线线两个版本，利于灾备

- 技术实现

  - next.js：服务器端渲染 React 组件框架, React 采用 ReactDOMServer 调用 `renderToString()`方法。

  - gatsby：服务端 React 渲染框架

  - nuxt.js：服务器端渲染 Vue 组件框架， Vue 采用 vue-server-renderer 调用 `renderToString()`方法

- 协作方式

  - 后端专注于业务功能实现和 API 接口封装。
  - 前端负责实现页面前端交互，根据后端 API 接口拼裝前端模板，页面渲染，以及服务器维护。

- 选型建议
  - 前端要处理 Node server 的机器环境、代码部署、日志、容灾、监控等以往后端人员需要具备运维知识，前端人员的综合能力要求会比以往要高。
  - 前端项目开发周期变长了，需要事先和产品、运营沟通排期问题。
  - 总之一名话：“前端人力和能力够，直接上马，向全栈工程师迈进“。

## 26 PWA：如何做到媲美原生应用的体验？

### 26.1 PWA

- 定义

  - Progressive Web App，简称 PWA, PWA 应用是使用特定技术和标准模式来开发的 Web 应用，这将同时赋予它们 Web 应用和原生应用的特性。

- 技术优势

  - 用户可以用手机屏幕启动应用，即使在离线状态或者弱网下，通过事先缓存的资源，也可正常加载运行当前应用，可以完全消除对网络的依赖，从而给用户非常可靠的体验。
  - 因为预先绶存了资源，部分资源无须经过网络，即秒开页面。
  - 和移动设备上的原生应用一样，具有沉浸式的用户体验。
  - 內容可以被搜索引擎收录。
  - 可以给用户发送离线推送消息。

- 技术实现

  - 全站改造成 HTPS，没有 HTTPS 就没有 ServiceWorker。
  - 应用 Service Worker 技术提升性能，离线提供静态资源文件，提升首屏用户体验。
  - 使用 App Manifest
  - 最后可以考虑离线消息推送等功能。

- 浏览器兼容性
  - Serviceworkerglobalscope API 88%
  - Web App Manifest 83%

## 27 页面渲染：怎样选择合理的技术方案？

### 27.1 页面渲染技术选型的合理化建议

- 存在即合理
- 依赖业务形式
- 依赖团队规模
- 依赖技术水平
- 没有银弹

## 28. 页面加载：加载策略都有哪些？又该如何选型？

### 28.1 懒加载

- 定义

  - 懒加载也叫延迟加载,指的是长网页中延迟加载特定元素(可以是图片,也可以是 JS/CSS 文件当然也可以是 Javascript 的特定函数和方法，以下简称“懒加载元素

- 好处

  - 可以减少当前屏无效资源的加載

- 实际方式和示例
  - 把页面上“懒加载元素” src 属性设置为空字符，把真实的 src 属性写在 data-lazy 属性中，当页面滚动的时候监听 scroll 事件，如果“懒加载元素“在可视区域内，就把图片的 src 属性或者文件 URL 路径设置成 data-lazy 属性值。

### 28.2 预加载

- 定义

  - 可以使用预加载让浏览器来预先加载某些资源(比如图片、JS/CSS/模板),而这些资源是在将来才会被使用到的。简单来说，就是将所需资源提前加载到浏览器本地，这样后面在需要使用的时候就可以直接从浏览器缓存中取了，而不用再重新开始加载。

- 好处
  - 减少用户后续加载资源等待的时间。
- 实现方式
  1. HTML 标签
  2. 使用 Image 对象
  3. 使用 preload, prefetch 和 preconnect

### 28.3 预渲染

- 好处

  1. 对于大型项目，在懒加载组件被加载之前，组件可能还会有其它懒加载组件的代码或数据，所以用户还是需要时间等待组件加载完成。
  2. 那另外一种预加载组件的方式就是提前渲染它，在页面中渲染组件，但是并不在页面中展示，也就是渲染好后先隐藏起来，用的时候再直接展示。

- 实现方式

  ```html
  <link rel="prerender" href="https://my.com" />
  ```

### 28.4 按需加载

- 常规按需加载（如 JS 原生、Jquery)
- 不同 App 按需加载（如 JS-SDK 脚本文件）
- 不同设备按需加载（如 PC 端和 HTML5 端样式文件
- 不同分辨率按需加载（CSS Media Query)

### 28.5 楼层式加载??

- 定义
  - 楼层数据异步加载和本地缓存相结合的方式

## 29 接口优化：如何对接口调用进行优化？.mp4

### 29.1 接口服务调用优化

1. 接口合并
   - 这个是指一个页面的众多的业务接口和依赖的第三方接口统一使一个部署在集群的接口统一调用，以减少页面接口请求数
2. 接口上 CDN
   - 主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至 CDN，等此接口內容变更之后自动同步至 CDN 集群上。如果一定时间內未请求到数据，会用源站接口再次请求
3. 接口域名上 CDN
   - 增强可用性、稳定性
4. 接口降级
   - 这个基于大促备战考虑，核心接口进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据。另外接口万ー无法访问，使用预设好的垫底备份数据。
5. 接口监控
   - 监控接口成功率，不是常说的 TP99, 而是和用户实际情况一致的成功和失败监控，包括比如弱网、超时、网络异常、网络切换等情況。排查出来问题需要联合后端、运维、网络岗位人员一并解决。

## 30. 接口优化：如何对接口缓存进行优化？

### 30.1 接口缓存策略优化

1. Ajax / fetch 缓存

- 前端请求时候带上 cache，依赖浏览器本身缓存机制。

2. 本地缓存

- 异步接口数据优先使用本地 localstorage 中的绥存数据

3. 多次请求

- 接口数据本地无 localstorage 缓存数据，重新再次发出 Ajaⅹ 请求。

## 31 WebView：如何选择合适的 WebView 内核？

### 31.1 iOS UlWebview

- 优点

  1. 从 iOS2 开始就作为 App 内展示 Web 内容的容器
  2. 排版布局能力强

- 不足

  1. 內存泄露
  2. 极高内存峰值
  3. Touch Delay (300ms 延迟）
  4. Javascript 的运行性能和通信限制
  5. 2018 年 i0S12 以后已经被标记为 Deprecated 不再维护

### 31.2 iOS WKWebView

- 优势

  1. 苹果在 WWDC2014 上推出的新一代 Webview 组件
  2. Wkwebview 的内存开销比 Uiwebview 小很多
  3. 在性能、稳定性、占用内存方面有很大提升
  4. 高达 60fps 的滚动刷新率
  5. 自身就支持了右滑返回手势
  6. 支持了更多的 HTML 的属性
  7. 内存占用是 UIWebView 的 1/4~1/3
  8. 加载速度比 UIWebView 提升了一倍左右
  9. 更为细致地拆分了 UIWebViewDelegate 中的方法
  10. 允许 Javascript 的 Nitro 库加载并使用（Uiwebview 中限制）大大提高了页面 JS 执行速度
  11. 可以和 JS 直接互调函数，不像 Uiwebview 需要第三方库 Webviewjavascriptbridge 来协助处理和 JS 的交互

- 不足

  1. 不支持页面缓存，需要自己注入 Cookie，而 Uiwebview 是自动注入 Cookie
  2. 无法发送 PO5T 参数问题

![image-20200316175938043](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-16-095948.png)

### 31.3 Android 第三方

- X5 内核
  1. 速度快。相比系统 WebView 的网页打开速度有 30+%的提升
  2. 省流量：使用云端优化技术使流量节省 20+%
  3. 更安全：安全问题可以在 24 小时内修复
  4. 更稳定：经过亿级用户的使用考验，CRASHE 率低于 0.15%
  5. 兼容好：无系统内核的碎片化问题，更少的兼容性问题
  6. 体验优：支持夜间模式、适屏排版、字体设置等浏览增强功能
  7. 功能全：在 H5、ES6 上有更完整支持
  8. 更强大：集成强大的视频播放器，支持视频格式远多于系统 Webview
  9. 视频和文件格式的支持 X5 内核多于系统內核
  10. 防劫持是 X5 内核的一大亮点

### 31.4 选型建议

- iOS: WKWebView

- Android: X5

## 32. 浏览器优化：如何设置全局 WebView？

### 32.1 启动过程

- 当 App 首次打开时，默认是并不初始化浏览器内核的
- 当创建 WebView 实例的时候，才会启动浏览器内核（打开时间需要 70~700ms），并创建 Webview 的基础框架。

### 32.2 实施步骤

- 使用全局 WebView 进行优化；
- 在客户端刚启动时，就初始化一个全局的 WebView 待用，并隐藏
- 当用户访问了 WebView 时，直接使用这个 WebView 加载对应网页，并展示。

### 32.3 具体流程

- 在初始页面上创建全局 Webview
- 根据页面跳转流向，确定目标网页
- 利用全局 Webview，加载目标网页对应的基础文件
- 向服务器发送请求消息，请求目标网页对应的网页数据
- 将请求到的网页数据渲染到初始页面上
- 运行状态切换为退出状态时，销毁 Webview。

### 32.4 选型建议

- 技术好处
  - 減少首次打开 Webview 时间
- 不足之处
  - 额外的一点内存消耗

## 33 浏览器优化：如何实现导航栏预加载？

### 33.1 导航栏预加载

- 原来
  - 在 Webview 加载完成之后进行初始化
- 现在
  - 和 Webview 并行一起加载

## 34 浏览器优化：如何打通登录态？

### 34.1 打通登录态

- 原来

  - HTML5 页面上接口每次查询，Cookies 里是否有登录态，无登录态 HTML5 跳转统一登陆页，app 拦截统一登陆页，进入原生登陆，原生登陆成功，在浏览器写登录态 Cookies。

- 现在
  - Cookies 由 app 发统一登录接口并埋上登录态 Cookies，并且在 Cookies 有效时间内无需再次请求登陆接口。

## 35 浏览器优化：如何实现 URL 预加载？

### 35.1 URL 预加载

- 原来
  - 所有准备好再请求页面
- 现在
  - 准备和请求页面同步进行，URL Load 和动画并行加载

## 36 浏览器优化：如何提升滚动条的使用体验？

### 36.1 提升滚动条的使用体验

- 原来

  - 采用系统自带进度条

- 现在
  - 模拟 WiFi 下页面加载过程，让用户感觉页面加載变快了

## 37 浏览器优化：如何对 JS-SDK 进行优化？

### 37.1 JS-SDK 优化

- 原来
  1. Scheme: 长度有限制
  2. Iframe：依赖 JSSDK.js 文件
- 现在
  - WebKit：无依赖 JSSDK.js 文件，直接调用

## 38. 浏览器优化：目前主流的缓存策略有哪些？

### 38.1 浏览器缓存策略

![image-20200317215416528](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-17-135419.png)

## 39-HTML5 离线化：主流的技术实现方案有哪些？

- 离线包类型

  - 全局离线包：包含公共的资源，可供多个应用共同使用
  - 私有离线包：只可以被某个应用单独使用

- 离线包架构

![image-20200317214651514](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-17-134654.png)

- 离线包下载

  - 如果用户处于移动网络下，不会在后台下载离线包；
  - 如果当前用户点击 app，离线包没有下载好，用户就要等待离线包下载好才能用

- 离线包运行模式
  - 请求包信息：从服务端请求离线包信息存储到本地数据库的过程。离线包信息包括离线包的下载地址、离线包版本号、加密/签名信息等。
  - 下载离线包：把离线包从服务端下载到手机。
  - 安装离线包：下载目录，拷贝到手机安装目录。

## 43. CDN：如何合理配置 CDN 缓存？

- CDN 定义

  - 内容分发网络（Content Delivery Network，简称 CDN）是利用最靠近每一位用户的服务器，更快、更可靠地将文件发送给用户分发网络

- CDN 优点

  - 提速：会给用户指派较近、较顺畅的服务器节点，将数据传输给用户低成本
  - 服务器被放到不同地点，減少了互连的流量，也降低了带宽成本
  - 高可用度：当某个服务器故障时，自动调用邻近地区的服务器

- CDN 回源

  - 回源是指浏览器访问 CDN 集群上静态文件时，文件绶存过期，直接穿透 CDN 集群而访问源站机器的形为。

- CDN 缓存

  - 三级缓存：浏览器本地缓存、CDN 边缘节点缓存、CDN 源站缓存

  - 缓存设置：缓存时间设置的过短，CDN 边绿节点缓存经常失效，导致频繁回源，增大了源站负载，访问也慢；缓存时间设置的过长，文件更新慢，用户本地缓存不能及时更新；所以结合业务情况而定

  - 不同静态资源类型绶存时间
    - HTML:3 分钟
    - JS、CSS:10 分钟、1 天、30 天

- CDN 缓存设置

![image-20200317220114838](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-17-140117.png)

- CDN 灰度发布

  - 原理：在部分地区、部分地区的部分运营商优先发布静态资源，验证通过后，再进行全量发布。
  - 实施：域名方面，设置特殊 ⅥP 解析至要灰度的城市、运营商；源站机器方面，给灰度的城市、运营商配置单独源站机器；灰度的城市、运营商解析至这些特有机器上

- CDN 大促备战

  - 增加机房带宽
  - 增加运苢商流量

  - 灾备：CDN 应用缓存时间由 10 分钟设置成 1 个小时，大促后恢复。

## 44. DNS：主流的 DNS 优化方法有哪些？

- 什么是 DNS

  - 域名系统（Domain Name System）是将网站域名和 IP 地址相互映射的一个分布式数据库，能够更方便的访问互联网。

- 客户端处理

  - AndroidDNS 模块（okhttp)
    - 支持 HTTP/2,HTP/2 通过使用多路复用技术在ー个单独的 TCP 连接上支持并发,通过在连接上一次性发送多个请求来发送或接收数据。
    - 如果 HTTP/2 不可用,连接池复用技术也可以极大减少延时
    - 支持 GZIP，可以压缩下载体积
    - 响应缓存可以完全避免网络重复请求。
    - 如果服务器配置了多个 IP 地址，当第一个 IP 连接失败的时候，Okhttp 会自动尝试下ー个 IP
  - IOS DNS 模块（自研）
    - App 启动时，缓存所有可能要用到的域名 IP，同时异步处理，客户端无需得到缓存结果
    - 如果 Cache 中有此域名的缓存，直接返回缓存的 IP
    - 如果缓存中没有此域名，则重新向 HTTPDNS SERVER 进行申请，结果会在此回调中返回。

- 前端处理

  - 浏览器并发数限制，分布设置成多个域名
    - 用户访问：Java、PHP 等 API 接口
    - 页面和样式: HTML/JS/CSS
    - 图片：jpg、png、gif 等

## 48. 服务器：如何开启和配置 gzip 压缩

- 好处

  - 对文本进行压缩(HTML/CSS/JS)
  - 而对非文本不压缩(jipg/gif/png/)
  - 压缩比约 50%-70%

- 配置方法

  - Nginx 配置： nginx.conf 文件增加 gzip on

  - Apache 配置：AddOutputFilterByType 和 AddOutputFilter

- 生效检测

  Response header 查看是否有 Content- Encoding: gzip，代表服务端已开启 gzip。

## 49. HTTPS：如何开启全站 HTTPS？

- 基本概念

  - HTTPS，超文本传输安全协议（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。
  - HTTPS 是经 HTTP 进行通信,但利用 SSL/TLS 进行数据加密。
  - HTTPS 主要目的是提供对服务器身份认证，保护数据隐私和完整性。

- 工作原理

  - 浏览器发起 HTTPS 请求

  - 传输证书

  - 浏览器解析证书

  - 传送加密信息

  - 服务器解密信息

  - 传输加密后的信息

  - 浏览器解密信息

- 优点

  - SEO

  - 安全

- 实施

  1. 经销商购买证书

     - GoGetSSL
     - SSLs.com
     - SSLmate.com

  2. 本地测试证书

     - 本地 Homebrew 安装

       - `brew install mkcert`

     - 本地安装根证书

       - `mkcert---install`

     - 本地生成签名
       - mkcert123.com // 生成 123.com 的证书
     - 本地 nginx 配置
       - ![image-20200319234240469](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-19-154244.png)

## 50. HTTP2：升级 HTTP2 的好处有哪些？如何升级？

- HTTP/2 概念

  - HTTP/2(超文本传输协议第 2 版,最初命名为 HTTP2.0),简称为 h2(基于 TLS/1.2 或以上版本的加密连接)或 h2c(非加密连接),是 HTTP 协议的的第二个主要版本。

- HTTP/2 优点

  - 采用二进制格式传输数据
  - 多路复用,允许通过一个 HTTP/2 连接发起多个请求
  - 对 Header 头压缩（Header Compression），伎输体积小
  - 服务端推送（Server Push），服务端能够更快的把资源推送给客户端

- HTTP/2 站点的优势

  - 可以降低服务器压力

  - 提升网站访问速度

  - 保护网站安全

- 在 Nginx 上启用 HTTP/2

  1. 升级 OpenSSL

     `openssl version`

  2. 重新编译

     ```shell
     cd nginx-xxx
     ./configure --with-http_ssl_module --with-http_v2_module
     make && make install
     ```

  3. 验证 HTTP/2

     浏览器下查看有没有小绿锁

  4. 浏览器请求截图

![image-20200320204438160](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-20-124440.png)

![image-20200320204529730](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2020-03-20-124532.png)

## 51 流程优化：如何优化前端团队的研发流程？

- 前端硏发流程
  - 技术选型（页面渲染技术和混合式开发技术）
  - 项目初始化（React、Vue、Angular）
  - 依赖模块引入（私有 NPM）
  - 本地开发（自研发前端工具）
  - 项目联调
  - 效果确认（产品、设计师确认）
  - 项目上线（部署系统）

## 52. 协作模式：前端和后端如何开展更高效的合作？

- 前后端协作模式
  - 前后端制定数据接口
  - 前端页面制作
  - 前端交互实现
  - 后端开发
  - 前后端联调
  - 前端上线
  - 后端上线

## 53. 自动化测试：有哪些主流的技术方案？如何选型？

- 自动化测试的方式方法

  - UI 自动化：上手简单，不过稳定性较差，工具有 appium、robot framework、selenium、artest 等。

- 接口自动化：稳定，性价比非常高，工具有，Java+ restassured，Python+requests， JMeter，HttpRunner

- 单元测试：性价比极高，一般由开发完成，但是有一些单元测试框架，比如 Junit5, bytes, unittest。测试这边可以了解，运用到自己的代码中

## 54. 自动化上线：有哪些方案可供选择？如何部署？

- 自动化部署与上线

  - 拉取代码库代码

  - 自动化工具在线打包编译
  - 代码上线部署至灰度机器
  - 代码上线部署至线上全量机器
  - CDN 后台静态文件更新缓存

## 55. 代码质量：如何有效提升团队整体的代码质量？

- 提升代码质量

  - 制定代码规范（小组内或者团队内）

  - 静态代码扫描（可以在上线系统里增加流程）

  - Codereview（高工或者小组内）
  - 阅读框架核心源码（站在巨人肩膀上）

## 56. 上线前：如何对 HTML5 的质量做即时检测？

- 上线前 H5 质量即时检测

  - 页面错误
  - JS 报错
  - 接口报错
  - 线上环境检测
  - 页面白屏

- 页面性能

  - 页面完全加载时检测

  - 前端 HTML、JS、CSS、压缩检测
  - 前端大 HTML、JS、CSS、大图检测
  - 前端 JS、CSS 个数检测
  - 服务器 GZiρ 检测
  - 服务器缓存设置检测

- 页面安全
  - HTTP 和 HTTPS 检测
  - XSS 检测
- 页面卡口

  - 运营（运营平台）
  - 研发（上线平台）

## 57. 上线后：如何进行 HTML5 的性能和错误监控？

- 上线后 H5 性能和错误监控

  - 页面性能监控

  - JS 错误监控
  - API 接口监控
  - 日志详情
  - 用户轨迹

- 统计报表

  - 大盘走势
  - 地域
  - 运营商
  - 浏览器

- 页面管理

- 性能指标

- 报警服务

## 58. 线上业务：如何进行线上业务的基调监控？

- 线上业务基调监控
  - 竞品分析
  - 多点监控
  - 告警服务

## 59. 发版后：如何进行 App 的性能和错误监控？

- 发版后 App 性能和错误监控
  - 网络请求
  - 启动监控
  - 崩溃监控
  - 页面监控
  - 网络监控
  - WebView 监控
  - 报警服务
