# 函数组合（Compose）

> 函数组合 compose
>
> 把多个函数通过嵌套的方式，把函数作为入参传入，把函数作为返回值传出，组合成为一个全新的函数，形成管道数据流。

一个例子

```js
function add(x) {
	return ++x;
}

function square(x) {
  return x * x;
}

function compose(f, g) {
  return function(x) {
    return g(f(x))
  } 
}

var addThenSquare = compose(add, squared);
var squareThenadd = compose(squared, add);
```

## 1. 实现compose函数

`compose`函数可以实现如下功能：

```js
function compose(...fns) {
  // ...
}

// compose(f, g)(x) === f(g(x))
// compose(f, g, m)(x) === f(g(m(x)))
// compose(f,g,m,n)(x) === f(g(m(n(x))))
```

我们可以看到`compose`函数，会接收若干个函数作为参数，每个函数执行后的输出作为下一个函数的输出，直至最后一个函数的输出作为最终的结果。

### 1. 1 实现组合

概括来说，就是接收若干个函数作为参数，返回一个新函数。新函数执行时，按照`由右向左`的顺序依次执行传入`compose`中的函数，每个函数的执行结果作为为下一个函数的输入，直至最后一个函数的输出作为最终的输出结果。

如果`compose`函数接收的函数数量是固定的，那么实现起来很简单也很好理解。

```js
function compose(f,g){
    return function(x){
        return f(g(x));
    }
}
```

只接收三个参数：

```js
function compose(f,g,m){
    return function(x){
        return f(g(m(x)));
    }
}
```

上面的代码，没什么问题，但是我们要考虑的是`compose`接收的参数个数是不确定的，我们考虑用rest参数来接收：

```js
function compose(...fns){
    return function(x){
        //···
    }
}
```

现在`compose`接收的参数`fns`是一个数组，那么现在思考的问题变成了，如何将数组中的函数`从右至左`依次执行。

我们选择数组的`reduceRight`函数来实现:

```js
function compose(...fns){
    return function(x){
        return fns.reduceRight(function(arg,fn){
            return fn(arg);
        },x)
    }
}
```

这样我们就实现了`compose`函数~

### 1.2 实现管道

`compose`的数据流是`从右至左`的，因为最右侧的函数首先执行，最左侧的函数最后执行！

但有些人喜欢`从左至右`的执行方式，即最左侧的函数首先执行，最右侧的函数最后执行！

> 从左至右处理数据流的过程称之为管道(pipeline)!

`管道(pipeline)`的实现同`compose`的实现方式很类似，因为二者的区别仅仅是数据流的方向不同而已。

对比`compose`函数的实现，仅需将`reduceRight`替换为`reduce`即可：

```js
function pipe(...fns){
    return function(x){
        return fns.reduce(function(arg,fn){
            return fn(arg);
        },x)
    }
}
```

与`组合`相比，有些人更喜欢`管道`。这只是个人偏好，与底层实现无关。重点是`pipe`和`compose`做同样的是事情，只是数据流放行不同而已！我们可以在代码中使用`pipe`或`compose`，但不要同时使用，因为这会在团队成员中引起混淆。如果要使用，请坚持只用一种组合的风格。

### 1.3 underscore compose的实现

```js
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
    };
};
```

## 2. 开发中组合的用处

假设我们有这样一个需求：给你一个字符串，将这个字符串转化成大写，然后逆序。

我们的常规思路如下：

```js
let str = 'jspool'

//先转成大写，然后逆序
function fn(str) {
    let upperStr = str.toUpperCase()
    return upperStr.split('').reverse().join('')
}

fn(str) // => "LOOPSJ"
```

这段代码实现起来没什么问题，但现在更改了需求，需要在将字符串大写之后，将每个字符拆开并封装成一个数组：

"jspool" => `["J","S","P","O","O","L"]`

为了实现这个目标，我们需要更改我们之前封装的函数，这其实就破坏了设计模式中的开闭原则。

> 开闭原则：软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。

那么在需求未变更，依然是字符串大写并逆序，应用组合的思想来怎么写呢？

原需求，我们可以这样实现：

```js
let str = 'jspool'

function stringToUpper(str) {
    return str.toUpperCase()
}

function stringReverse(str) {
    return str.split('').reverse().join('')
}

let toUpperAndReverse = compose(stringReverse, stringToUpper)
let result = toUpperAndReverse(str) // "LOOPSJ"
```

那么当我们需求变化为字符串大写并拆分为数组时，我们根本不需要修改之前封装过的函数：

```js
let str = 'jspool'

function stringToUpper(str) {
    return str.toUpperCase()
}

function stringReverse(str) {
    return str.split('').reverse().join('')
}

function stringToArray(str) {
    return str.split('')
}

let toUpperAndArray = compose(stringToArray, stringToUpper)
let result = toUpperAndArray(str) // => ["J","S","P","O","O","L"]
```

可以看到当变更需求的时候，我们没有打破以前封装的代码，只是新增了函数功能，然后把函数进行重新组合。

> 可能有人会有疑问，应用组合的方式书写代码，当需求变更时，依然也修改了代码，不是也算破坏了开闭原则么？其实我们修改的是调用的逻辑代码，并没有修改封装、抽象出来的代码，而这种书写方式也正是开闭原则所提倡的。

我们假设，现在又修改了需求，现在的需求是，将字符串转换为大写之后，截取前3个字符，然后转换为数组，那么我们可以这样实现：

```js
let str = 'jspool'

function stringToUpper(str) {
    return str.toUpperCase()
}

function stringReverse(str) {
    return str.split('').reverse().join('')
}

function getThreeCharacters(str){
    return str.substring(0,3)
}

function stringToArray(str) {
    return str.split('')
}

let toUpperAndGetThreeAndArray = compose(stringToArray, getThreeCharacters,stringToUpper)
let result = toUpperAndGetThreeAndArray(str) // => ["J","S","P"]
```

从这个例子，我们可以知道，组合的方式是真的就是抽象单一功能的函数，然后再组成复杂功能，不仅代码逻辑更加清晰，也给维护带来巨大的方便。

## 扩展阅读

- [JavaScript专题之函数组合](https://juejin.im/post/59a8ccf8f265da2498241625#heading-5)
- [「前端进阶」彻底弄懂函数组合](https://juejin.im/post/5d50bfebf265da03cb122b6f#heading-4)
- [Koa引用库之Koa-compose](https://juejin.im/post/59c00a39f265da064c3853b7)