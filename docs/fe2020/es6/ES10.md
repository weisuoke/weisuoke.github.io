# ES2019(ES10)

[[TOC]]

## 1. Array.prototype.flat && Array.prototype.flatMap

> The `**flat()**` method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.

**Syntax**

```js
var newArray = arr.flat([depth]);
```

**Examples**

1. Flattening nested arrays

```js
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

2. Flattening and array holes

```js
var arr5 = [1, 2, , 4, 5];
arr5.flat();
// [1, 2, 4, 5]
```

## 2. Array.prototype.flatMap

> The `**flatMap()**` method first maps each element using a mapping function, then flattens the result into a new array. It is identical to a `map()`followed by a `flat()`of depth 1, but `flatMap()` is often quite useful, as merging both into one method is slightly more efficient.

**Syntax**

```js
var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {
    // return element for new_array
}[, thisArg])
```

**Examples**

```js
let arr1 = [1, 2, 3, 4];

arr1.map(x => [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x => [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap(x => [[x * 2]]);
// [[2], [4], [6], [8]]
```

```js
// Let's say we want to remove all the negative numbers and split the odd numbers into an even number and a 1
let a = [5, 4, -3, 20, 17, -33, -4, 18];
//       |\  \  x   |  | \   x   x   |
//      [4,1, 4,   20, 16, 1,       18]

a.flatMap(n => (n < 0 ? [] : n % 2 == 0 ? [n] : [n - 1, 1]));

// expected output: [4, 1, 4, 20, 16, 1, 18]
```

## 3. Object.fromEntries()

> The `Object.fromEntries()` method transforms a list of key-value pairs into an object.

**Syntax**

```js
Object.fromEntries(iterable);
```

**Examples**

1. **Converting a `Map` to an `Object`**

```js
const map = new Map([
  ["foo", "bar"],
  ["baz", 42]
]);
const obj = Object.fromEntries(map);
console.log(obj); // { foo: "bar", baz: 42 }
```

2. **Converting an `Array` to an `Object`**

```js
const arr = [
  ["0", "a"],
  ["1", "b"],
  ["2", "c"]
];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }
```

3. **Object transformations**

```js
const object1 = { a: 1, b: 2, c: 3 };

const object2 = Object.fromEntries(
  Object.entries(object1).map(([key, val]) => [key, val * 2])
);

console.log(object2);
// { a: 2, b: 4, c: 6 }
```

## 4. String.trimStart()

`trimStart()` ：删除字符串的开头空格。

## 5. String.trimEnd()

`trimEnd()` ：删除字符串末尾的空格。

## 6. Optional Catch Binding (catch 的参数可以省略)

## 7. **Array.Sort Stability**

## 8. Symbol.description

`description` 是一个只读属性，它会返回 `Symbol` 对象的可选描述的字符串。

```js
let mySymbol = "My Symbol";
let symObj = Symbol(mySymbol);
symObj; // Symbol(My Symbol)
symObj.description; // "My Symbol"
```

### 9. Nullish Coalescing Operator

```js
const y = x ?? 500;
```

```js
const x = null;
const y = x ?? 500;
console.log(y); // 500

const n = 0;
const m = n ?? 9000;
console.log(m); // 0
```

### 10. BigInt

**BigInt** 是第七种 原始类型。

BigInt 是一个任意精度的整数。这意味着变量现在可以 `表示²⁵³` 数字，而不仅仅是`9007199254740992`。

```js
const b = 1n; // 追加 n 以创建 BigInt
```

在过去，不支持大于 `9007199254740992` 的整数值。如果超过，该值将锁定为 `MAX_SAFE_INTEGER + 1`

```js
const limit = Number.MAX_SAFE_INTEGER;
⇨ 9007199254740991
limit + 1;
⇨ 9007199254740992
limit + 2;
⇨ 9007199254740992 <--- MAX_SAFE_INTEGER + 1 exceeded
const larger = 9007199254740991n;
⇨ 9007199254740991n
const integer = BigInt(9007199254740991); // initialize with number
⇨ 9007199254740991n
const same = BigInt("9007199254740991"); // initialize with "string"
⇨ 9007199254740991n
```

### 11. Promise.allSettled

我们知道 Promise.all 具有并发执行异步任务的能力。但它的最大问题就是**如果参数中的任何一个 promise 为 reject 的话，则整个 Promise.all 调用会立即终止**，并返回一个 reject 的新的 Promise 对象。

```js
const promises = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.reject("error")
];

Promise.all(promises)
  .then(responses => console.log(responses))
  .catch(e => console.log(e)); // "error"
```

假如有这样的场景：一个页面有三个区域，分别对应三个独立的接口数据，使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是 reject,这会导致页面中该三个区域数据全都无法出来，这个状况我们是无法接受，Promise.allSettled 的出现就可以解决这个痛点：

```js
Promise.allSettled([
  Promise.reject({ code: 500, msg: "服务异常" }),
  Promise.resolve({ code: 200, list: [] }),
  Promise.resolve({ code: 200, list: [] })
]).then(res => {
  console.log(res);
  /*
        0: {status: "rejected", reason: {…}}
        1: {status: "fulfilled", value: {…}}
        2: {status: "fulfilled", value: {…}}
    */
  // 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染
  RenderContent(
    res.filter(el => {
      return el.status !== "rejected";
    })
  );
});
```

Promise.allSettled 跟 Promise.all 类似, 其参数接受一个 Promise 的数组, 返回一个新的 Promise, **唯一的不同在于, 它不会进行短路**, 也就是说当 Promise 全部处理完成后,我们可以拿到每个 Promise 的状态, 而不管是否处理成功。

## A. 参考阅读

- [20 多个小事例带你重温 ES10 新特性](https://juejin.im/post/5d8ff489f265da5ba46f3f9e#heading-11)
- [JavaScript new features in ES2019(ES10)](https://medium.com/javascript-in-plain-english/javascript-es2019-es10-in-a-nutshell-cae6f7524519)
- [ES2020 新特性](https://juejin.im/post/5e1bcaa1f265da3e140fa3ee#heading-3)
