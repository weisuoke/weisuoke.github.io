# 	React中使用ts基础

## 1. 准备工作

1. Create React App v2.1 + with TypeScript:	`npx create-react-app my-new-react-typescript-app --typescript`
2. Basarat's guide for manual setup of React + TypeScript + Webpack + Babel
   - 确认安装 @types/react 和 @types/react-dom

### 引入React

```jsx
import * as React from 'react'
import * as ReactDOM from 'react-dom'
```

在 TypeScript 2.7+，可以使用 `--allowSyntheticDefaultImports`，或者在 tsconfig.json 中配置 `allowSyntheticDefaultImports: true;`

```typescript
import React from 'react'
import ReactDOM from 'react-dom'
```



## 2. 开始

### 2.1 Function Components

**方法1**

```tsx
const App = ({ message }: { message: string }) => <div>{ message }</div>
```

**方法2**: 使用泛型

```tsx
const App: React.FC<{ message: string }> = ({ message }) => (
  <div>{ message }</div>
);	// React.FunctionComponent alse works
```

### 2.2 Class Components

使用`React.Component<PropType, StateType>`

```tsx
type MyProps = {
  // using `interface` is also ok
  message: string;
};

type MyState = {
  count: number;	// like this
};

class App extends React.Component<MyProps, MyState> {
  state: MyState = {
    // optional second annotation for better type inference
    count: 0
  };
  render() {
    return (
      <div>
      	{this.props.message} {this.state.count}
      </div>
    )
  }
}
```

通过 export/import/extend 来使得这些 types/interface 重用

*类方法*: 在类方法参数需要加类型

```tsx
class App extends React.Component<{ message: string }, { count: number }> {
  state = { count: 0 };
  render() {
    return (
      <div onClick={() => this.increment(1)}>
      	{this.props.message} {this.state.count}
      </div>
    );
  }
  increment = (amt: number) => {
    // like this
    this.setState(state => {
      count: state.count + amt
    })
  }
}
```

*类属性*：属性先声明

```tsx
class App extends React.Component<{
  message: string;
}> {
  pointer: number;	// like this
  componentDidMount() {
    this.pointer = 3;
  }
  render() {
		return (
      <div>
      	{ this.props.message } and { this.pointer }
      </div>
    )
  }
}
```

### 2.3 defaultProps

**function component**

```tsx
type Props = { age: number } & typeof defaultProps;
const defaultProps = {
  who: 'Johny Five',
};

const Greet = (props: Props) => {
  /*...*/
};

Greet.defaultProps = defaultProps
```

**Class components**

```tsx
type GreetProps = typeof Greet.defaultProps & {
  age: number
}

class Greet extends React.Component<GreetProps> {
  static defaultProps = {
    name: 'world'
  }
  /*...*/
}

// Type-checks! No type assertions needed!
let el = <Greet age={3} />;
```



### 2.4 基本属性类型

```tsx
type AppProps = {
  message: string;
  count: number;
  disabled: boolean;
  /** array of a type! */
  names: string[];
  /** string literals to specify exact string values, with a union type to join them together */
  status: 'waiting' | 'success';
  /** any object as long as you dont use its properties (not common) */
  obj: object;
  obj2: {};	// same
  /** an object with defined properties (preferred) */
  obj3: {
    id: string;
    title: string;
  };
  /** array of objects! (common) */
  objArr: {
    id: string;
    title: string;
  }[];
  /** any function as long as you don't invoke it (not recommended) */
  onSomething: Function;
  /** function that doesn't take or return anything (VERY COMMON) */
  onClick: () => void;
  /** function with named prop (VERY COMMON) */
  onChange: (id: number) => void;
  /** an optional prop (VERY COMMON!) */
}
```

### 2.5 有用的React属性类型

```tsx
export declare interface AppProps {
  children1: JSX.Element;	// bad, doesnt account for arrays
  children2: JSX.Element | JSX.Element[];	// meh, doesnt accept functions
  children3: React.ReactChildren;	// despite the name, not at all an appropriate type; it is a utility
  children4: React.ReactChild[];	// better
  children: React.ReactNode;	// best, accepts everything
  functionChildren: (name: string) => React.ReactNode; // recommended function as a child render prop type
  style?: React.CSSProperties;	// to pass through style props
  onChange?: React.FormEventHandler<HTMLInputElement>;	// form events! the generic parameter is the type of event.target
  props: Props & React.PropsWithoutRef<JSX.IntrinsicElements['button']>;
}
```

> JSX.Element vs React.ReactNode



### 2.6 Forms and Events

两种写法：

**方法1**

```tsx
class App extends React.Component<
	{},
  {
    // no props
    text: string;
  }
> {
  state = {
    text: ''
  };
  
  // typing on RIGHT hand side of =
  onChange = (e: React.FormEvent<HTMLInputElement>): void => {
    this.setState({ text: e.currentTarget.value });
  };
  render() {
    return (
      <div>
      	<input type="text" value={this.state.text} onChange={this.onChange} />
      </div>
    )
  }
}
```

替代`React.FormEvent`和`void`的方法

**方法2**

```tsx
// typing on LEFT hand side of =
onChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
  this.setState({ text: e.currentTarget.value })
}
```

> 为什么这两种方法能做相同的事情？

### 2.7 Context

使用新的Context API`React.createContext`：

```tsx
interface ProviderState {
  themeColor: string;
}

interface UpdateStateArg {
  key: keyof ProviderState;
  value: string;
}

interface ProviderStore {
  state: ProviderState;
  update: (arg: UpdateStateArg) => void;
}

const Context = React.createContext({} as ProviderStore);	// type assertion on empty object

class Provider extends React.Component<{}, ProviderState> {
  public readonly state = {
    themeColor: 'red'
  };
  
  private update = ({ key, value }: UpdateStateArg) => {
    this.setState({ [key]: value })
  };
  
  public render() {
    const store: ProviderStore = {
      state: this.state,
      update: this.update
    };
    
    return (
      <Context.Provider value={store}>{this.props.children}</Context.Provider>
    )
  }
}
```

### 2.8 forwardRef/createRef

`createRef`:

```tsx
class CssThemeProvider extends React.PureComponent<Props> {
  private rootRef = React.createRef<HTMLDivElement>();	// like this
  render() {
    return <div ref={this.rootRef}>this.props.children</div>
  }
}
```

`forwardRef`：

```tsx
type Props = { children: React.ReactNode; type: 'submit' | 'button' };
export type Ref = HTMLButtonElement;
export const FancyButton = React.forwardRef<Ref, Props>((props, ref) => {
  <button ref={ref} className="MyClassName" type={props.type}>
  	{props.children}
  </button>
})
```

[react-refs-with-typescript](<https://medium.com/@martin_hotell/react-refs-with-typescript-a32d56c4d315>)

### 2.9 Portals

Using `ReactDOM.createPortal`:

```tsx
const modalRoot = document.getElementById('modal-root') as HTMLElement;
// assuming in your html file has a div with id 'modal-root';

export class Modal extends React.Component {
  el: HTMLElement = document.createElement('div');
  
  componentDidMount() {
    modalRoot.appendChild(this.el);
  }
  
  componentWillUnmount() {
    modalRoot.removeChild(this.el)
  }
  
  render() {
    return ReactDOM.createPortal(this.props.children, this.el);
  }
}
```



## 3. React中的Types使用

### 3.1 联合类型 和 类型保护

**联合类型**

```tsx
class App extends React.Component<
	{},
  {
    count: number | null;	// like this
  }
> {
  state = {
    count: null
  };
  render() {
    return <div onClick={() => this.increment(1)}>{this.state.count}</div>
  };
  increment = (amt: number) => {
    this.setState(state => ({
      count: (state.count || 0) + amt
    }))
  };
}
```

**类型保护**

```tsx
interface Admin {
  role: string;
}
interface User {
  email: string;
}

// Method 1: use `in` keyword
function redirect(usr: Admin | User) {
  if ("role" in usr) {	// use the `in` Operator for typeguards since TS 2.7+
    routeToAdminPage(usr.role);
  } else {
    routeToHomePage(usr.email);
  }
}

// Method 2: custom type guard, does the same thing in older TS versions or where `in` isnt enough
function isAdmin(usr: Admin | User): usr is Admin {
  return (<Admin>usr).role !== undefined
}
```

### 3.2 可选类型

```tsx
class MyComponent extends React.Component<{
  message?: string;	// like this
}> {
  render() {
    const { message = 'default' } = this.props;
    return <div>{message}</div>
  }
}
```

### 3.3 枚举类型

TypeScript中的枚举类型默认使用的是number类型，你也使用string来替代：

```tsx
export enum ButtonSizes {
  default = 'default',
  small = 'small',
  large = 'large'
}
```

使用

```tsx
export const PrimaryButton = (
	props: Props & React.HTMLProps<HTMLButtonElement>
) => <Button size={ButtonSizes.default} {...props} />
```

一个更加简单的替换枚举，是使用一串字符

```tsx
export declare type Position = 'left' | 'right' | 'top' | 'bottom'
```

### 3.4 类型断言

Sometimes TypeScript is just getting your type wrong, or union types need to be asserted to a more specific type to work with other APIs, so assert with the `as` keyword. This tells the compiler you know better than it does.

```tsx
class MyComponent extends React.Component<{
  message: string;
}> {
  render() {
    const { message } = this.props
    return (
      <Component2 message={message as SpecialMessageType}>{message}</Component2>
    )
  }
}
```

### 3.5 交叉类型

### 3.6 使用类型推断

```tsx
const [state, setState] = React.useState({
  foo: 1,
  bar: 2
});	// state's type inferred to be {foo: number, bar: number}

const someMethod = (obj: typeof state) => {
  // grabbing the type of state even though it was inferred
  // some code using obj
  setState(obj); // this works
}
```

### 3.7 使用部分类型

Working with slicing state and props is common in React. Again, you don't really have to go and explicitly redefine your types if you use the `Partial` generic type:

```tsx
const [state, setState] = React.useState({
  foo: 1,
  bar: 2
});	// state's type inferred to be {foo: number, bar: number}

// NOTE: stale state merging is not actually encouraged in React.useState
// We are just domonstrating how to use Partial here
const partialStateUpdate = (obj: Partial<typeof state>) => setState({ ...state, ...obj })

// later on...
partialStateUpdate({ foo: 2 });	// this works
```

### 3.8 没有导出的类型

This can be annoying but here are ways to grab the types!

- Grabbing the Prop types of a component: Use `React.ComponentProps` and `typeof`, and optionally `Omit` any overlapping types

```tsx
import { Button } from 'library'; // but doesn't export ButtonProps! oh no!
type ButtonProps = React.ComponentProps<typeof Button>; // no problem! grab your own!
type AlertButtonProps = Omit<ButtonProps, 'onClick'>; // modify
const AlertButton: React.FC<AlertButtonProps> = props => (
  <Button onClick={() => alert('hello')} {...props} />
);
```

You may also use [`ComponentPropsWithoutRef`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5565fe5e46e329a5ee02ddf739abe11bf16f278d/types/react/index.d.ts#L739) (instead of ComponentProps) and [`ComponentPropsWithRef`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5565fe5e46e329a5ee02ddf739abe11bf16f278d/types/react/index.d.ts#L735) (if your component specifically forwards refs)

- Grabbing the return type of a function: use `ReturnType`:

```tsx
// inside some library - return type { baz: number } is inferred but not exported
function foo(bar: string) {
  return { baz: 1 };
}

//  inside your app, if you need { baz: number }
type FooReturn = ReturnType<typeof foo>; // { baz: number }
```

## 4. 图片和其他非TS/TSX文件

```tsx
// declaration.d.ts
// anywhere in your project, NOT the same name as any of your .ts/tsx file
declare module '*.png'

// importing in a tsx file
import * as logo from "./logo.png"
```

## 5. TSLint

## 6. tsconfig.json

```json
{
  "compilerOptions": {
    "outDir": "build/lib",
    "module": "commonjs",
    "target": "es5",
    "lib": ["es5", "es6", "es7", "es2017", "dom"],
    "sourceMap": true,
    "allowJs": false,
    "jsx": "react",
    "moduleResolution": "node",
    "rootDir": "src",
    "baseUrl": "src",
    "forceConsistentCasingInFileNames": true,
    "noImplicitReturns": true,
    "strict": true,
    "esModuleInterop": true,
    "suppressImplicitAnyIndexErrors": true,
    "noUnusedLocals": true,
    "declaration": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "build", "scripts"]
}
```

- `esModuleInterop`: disables namespace imports (`import * as foo from "foo"`) and enables CJS/AMD/UMD style imports (`import fs from "fs"`)