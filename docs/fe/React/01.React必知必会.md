# React必知必会

## React 组件

> 1. 组件的种类
> 2. 组件和元素有什么区别

**组件的种类 **

*1.1`React.createClass()`*

```jsx
var Greeting = React.createClass({
  render: function() {
    return <h1>Hello, {this.props.name}</h1>
  }
})
```
*1.2 ES6 class*

```jsx
class Greeting extends React.Component {
  render: function() {
    return <h1>Hello, {this.props.name}</h1>
  }
}
```
1.3 无状态函数

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}</h1>
}
```

*1.4 PureComponent*

> 在 Pure Component 中使用渲染属性会有什么问题?



**元素与组件的区别**

组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。

## 组件通信

- [React组件之间的通信](<https://github.com/sunyongjian/blog/issues/27>)

> React组件通信的方式
>
> 1. 父子组件 父->子 prop 子->父 callback
> 2. 兄弟组件 上层Container
> 3. 爷孙组件 context API
> 4. 任意组件 发布订阅模式 
> 5. 状态管理工具 Redux/Mobx




## React的生命周期

![](https://github.com/semlinker/reactjs-interview-questions/blob/master/images/phases.png)

> Before 16.3 React 生命周期钩子
>
> - componentWillMount()
> - componentDidMount()
> - componentWillReceiveProps()
> - shouldComponentUpdate()
> - componentWillUpdate()
> - componentDidUpdate()
> - componentWillUnmount()
>
> React 16.3+
>
> - getDerivedStateFromProps
> - componentDidMount
> - shouldComponentUpdate
> - getSnapshotBeforeUpdate
> - componentDidUpdate
> - componentWillUnmount

**生命周期的各个阶段**

挂载阶段
1. constructor()
2. componentWillMount()
3. render()
4. componentDidMount()

更新阶段 - 父组件更新 (New props)
1. componentWillReceiveProps()
2. shouldComponentUpdate()
3. componentWillUpdate()
4. render()
5. componentDidUpdate()

更新阶段 - setState()
1. shouldComponentUpdate()
2. componentWillUpdate()
3. render()
4. componentDidUpdate()

更新阶段 - forceUpdate 强制更新
1. componentWillUpdate()
2. render()
3. componentDidUpdate()

卸载阶段
1. componentWillUnmount()

**React 16以后的生命周期**

![](https://github.com/semlinker/reactjs-interview-questions/blob/master/images/phases16.3.jpg)

组件生命周期有三个不同的生命周期阶段：

<span style="color: red;">1. Mounting</span>

组件已准备好挂载到浏览器的DOM中，此阶段包含来自 `constructor()`, getDeivedStateFromProps(), render() 和 componentDidMount() 生命周期方法中的初始化过程。

<span style="color: red;">2. Updating</span>

在此阶段，组件以两种方式更新，发送新的属性并使用 `setState()` 或 `forceUpdate()` 方法更新状态. 此阶段包含 `getDerivedStateFromProps()`, `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()` 和 `componentDidUpdate()` 生命周期方法。

<span style="color: red;">3. Unmounting</span>

在这个最后阶段，不需要组件，它将从浏览器 DOM 中卸载。这个阶段包含 `componentWillUnmount()`生命周期方法。

值得一提的是，在将更改应用到 DOM 时，React 内部也有阶段概念。它们按如下方式分隔开：

<span style="color: red;">1. Render</span>

组件将会进行无副作用渲染。这适用于纯组件（Pure Component），在此阶段，React 可以暂停，中止或重新渲染。

<span style="color: red;">2. Pre-commit</span>

在组件实际将更改应用于 DOM 之前，有一个时刻允许 React 通过`getSnapshotBeforeUpdate()`捕获一些 DOM 信息（例如滚动位置）。

<span style="color: red;">3. Commit</span>

React 操作 DOM 并分别执行最后的生命周期： `componentDidMount()` 在 DOM 渲染完成后调用, `componentDidUpdate()` 在组件更新时调用, `componentWillUnmount()` 在组件卸载时调用。 React 16.3+ 阶段 




## 事件绑定

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true }
    
    // 为了在回调中使用 `this`, 这个绑定时必不可少的
    this.handleClick = this.handleClick.bind(this)
  }
  
  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }
  
  render() {
    return (
    	<button onClick={this.handleClick}>
    		{this.state.isToggleOn ? 'ON' : 'OFF'}
    	</button>
    )
  }
}
```



```jsx
class LoggingButton extends React.Component {
  // 这个语法确保 `this` 绑定在 handleClick 中。
  // 警告：这是 *实验性的* 语法。
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```



```jsx
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      <button onClick={(e) => this.handleClick(e)}>
        Click me
      </button>
    );
  }
}
```



> 三种事件绑定的方式区别，优缺点。



## setState

> Q&A
>
> 1. setState是同步的还是异步的
> 2. 什么场景是异步的，可不可能同步，什么场景下又是同步的
> 3. setState被调用后更新组件的过程？

**0. Awesome**

- [你真的理解setState吗？](<https://zhuanlan.zhihu.com/p/39512941>)
- [揭秘React setState](<https://juejin.im/post/5b87d14e6fb9a01a18268caf>)

**1. 什么是setState?**

setState是react里面一个重要的方法，更新状态`state`使用。

**结论**

> 1. `setState` 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。
> 2. `setState` 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 `setState(partialState, callback)` 中的callback拿到更新后的结果。
> 3. `setState` 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。



## JSX

## Hooks

React v16.8 提出来的一个概念。

**Awesome**

- [react-hanger]()

**1. 什么是Hooks**

> 我的理解是
>
> 提供一些API在Function Components中使用state等

**2. Hooks产生的背景**

React世界中，有容器组件和UI组件之分，在React Hooks出现之前，UI组件我们可以使用函数，无状态组件来展示UI，而对于容器组件，函数组件就显得无能为力，我们依赖类组件来获取数据，处理数据，并向下传递给UI组件进行渲染。

**3. 使用方式**

*3.1 useState 保存组件状态*

```jsx
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

function App() {
  const [obj, setObject] = useState({
    count: 0,
    name: "alife"
  });
  return (
    <div className="App">
      Count: { obj.count }
      <button onClick={() =>setObject({...obj, count: obj.count + 1})}>+</button>
      <button onClick={() =>setObject({...obj, count: obj.count - 1})}>-</button>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

*3.2 useEffect 处理副作用*

> Q & A 
>
> 1. Hooks之前怎么处理副作用的。
> 2. 什么是副作用？

函数组件能保存状态，但是对于异步请求，副作用的操作还是无能为力，所以 React 提供了 useEffect 来帮助开发者处理函数组件的副作用，在介绍新 API 之前，我们先来看看类组件是怎么做的：

```jsx
import React, { Component } from 'react';

class App extends Component {
  state = {
    count: 1
  };
  componentDidMount() {
		const { count } = this.state;
    document.title = "componentDidMount" + count;
    this.timer = setInterval(() => {
      this.setState(({ count }) => ({
        count: count + 1
      }));
    }, 1000);
  }
  componentDidUpdate() {
		const { count } = this.state;
    document.title = "componentDidMount" + count;
  }
  componentWillUnmount() {
		const { count } = this.state;
    clearInterval(this.timer);
  }
  render() {
    const { count } = this.state;
    return (
      <div>
        Count:{count}
        <button onClick={() => clearInterval(this.timer)}>clear</button>
      </div>
    );
  }}
}
```

在例子中，组件每隔一秒更新组件状态，并且每次触发更新都会触发 document.title 的更新(副作用)，而在组件卸载时修改 document.title（类似于清除）

从例子中可以看到，一些重复的功能开发者需要在 componentDidMount 和 componentDidUpdate 重复编写，而如果使用 useEffect 则完全不一样。

```jsx
import React, { useState, useEffect } from 'react'
import ReactDOM from 'react-dom'

let timer = null;

function App() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = "componentDidMount" + count;
  }, [count]);

  useEffect(() => {
    timer = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);
    return () => {
      document.title = 'componentWillUnmount';
      clearInterval(timer);
    }
  }, [])

  return (
    <div>
      Count: { count }
      <button onClick={() => clearInterval(timer)}>clear</button>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

我们使用 useEffect 重写了上面的例子，useEffect 第一个参数传递函数，可以用来做一些副作用比如异步请求，修改外部参数等行为，而第二个参数是个数组，如果数组中的值才会触发 useEffect 第一个参数中的函数。返回值(如果有)则在组件销毁或者调用函数前调用。

- 比如第一个 useEffect 中，理解起来就是一旦 count 值发生改变，则修改 documen.title 值
- 而第二个 useEffect 中数组没有传值，代表不监听任何参数变化，即只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount



*3.3 useContext 减少组件层级*

> Q & A
>
> 1. React中的组件通信是怎样进行的
> 2. Context API是什么？
> 3. useContext 与 Context API 的区别是什么？
> 4. 设计上你会去怎么设计。



*3.4 useReducer*

> 相当于迷你版本的Redux

*3.5 useCallback记忆函数*

*3.6 useMemo 记忆组件*

*3.7 useRef 保存引用值*

*3.8 useImperativeHandle 透传 Ref*

*3.9 useLayoutEffect 同步执行副作用*



## 高阶组件(HOC)

> Q & A
>
> 1. 什么是高阶组件？
>
> 2. 为什么要设计高阶组件？
>
> 3. 高阶组件解决了什么具体的问题？
>
> 4. 如何使用渲染属性创建 HOC?
> 
> 5. HOC 有哪些限制?
> 
> 6. 什么是 HOC 工厂实现?

**0. 参考阅读**

> - [React 中的高阶组件及其应用场景](<https://juejin.im/post/5c72b97de51d4545c66f75d5>)

**1. 什么是高阶组件**

> 高阶函数：如果一个函数 **接受一个或多个函数作为参数或者返回一个函数** 就可称之为 **高阶函数**。

```javascript
// 一个简单的高阶函数
function withGreeting(greeting = () => {}) {
    return greeting;
}
```

高阶组件的定义和高阶函数非常相似

> 如果一个函数 **接受一个或多个组件作为参数并且返回一个组件** 就可称之为 **高阶组件**。

```java
function HigherOrderComponent(WrappedComponent) {
    return <WrappedComponent />;
}
```



## render props

## Reconciliation

## Context API

> 在使用 context 时，如何解决性能方面的问题?
> 你是怎么使用 contextType
> 在 context 中默认值的目的是什么?
> 举例说明如何使用 context?

## 错误边界

**V16**

错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。

如果一个类组件定义了一个名为 `componentDidCatch(error, info)`或`static getDerivedStateFromError()`新的生命周期方法，则该类组件将成为错误边界。

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }
  
  componentDidCatch(error, info) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, info)
  }
  
  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI
    return { hasError: true }
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>{'Something went wrong'}</h1>
    }
    return this.props.children
  }
}
```

之后，将其作为常规组件使用

```jsx
<ErrorBoundary>
	<MyWidget />
</ErrorBoundary>
```

**V15**

React v15 使用 `unstable_handleError`的方法为错误边界提供了非常基础的支持。已经在V16中，将其重命名为`componentDidCatch`

## 受控组件和非受控组件

> 什么是受控组件和非受控组件？
>
> 两者的区别，什么场景下使用。
>
> 如何设置非受控组件的默认值

**1. 受控组件**

> 在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 [`setState()`](https://zh-hans.reactjs.org/docs/react-component.html#setstate)来更新。
>
> 我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

由于在表单元素上设置了 `value` 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。由于 `handlechange` 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

对于受控组件来说，每个 state 突变都有一个相关的处理函数。这使得修改或验证用户输入变得简单。例如，如果我们要强制要求所有名称都用大写字母书写，我们可以将 `handlechange` 改写为：

```jsx
handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
```

**2. 非受控组件**

> 在大多数情况下，我们推荐使用 [受控组件](https://zh-hans.reactjs.org/docs/forms.html) 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。

要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 [使用 ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html) 来从 DOM 节点中获取表单数据。

例如，下面的代码使用非受控组件接受一个表单的值：

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

**3 非受控组件默认值**

在 React 渲染生命周期时，表单元素上的 `value` 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 `defaultValue` 属性，而不是 `value`。

```jsx
render() {
  return (
    <form onSubmit={this.handleSubmit}>
      <label>
        Name:
        <input
          defaultValue="Bob"
          type="text"
          ref={this.input} />
      </label>
      <input type="submit" value="Submit" />
    </form>
  );
}
```

同样，`<input type="checkbox">` 和 `<input type="radio">` 支持 `defaultChecked`，`<select>` 和 `<textarea>` 支持 `defaultValue`。

## Portals

> - Portals 是什么？
> - portals 的典型使用场景是什么?

**1. Portals是什么?**

> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

```jsx
ReactDOM.createPortal(child, container)
```

第一个参数（`child`）是任何[可渲染的 React 子元素](https://zh-hans.reactjs.org/docs/react-component.html#render)，例如一个元素，字符串或 fragment。第二个参数（`container`）是一个 DOM 元素。

**2. 用法**

通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：

```jsx
render() {
  // React 挂载了一个新的 div，并且把子元素渲染其中
  return (
    <div>
      {this.props.children}
    </div>
  );
}
```

然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的：

```jsx
render() {
  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个可以在任何位置的有效 DOM 节点。
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```

一个 portal 的典型用例是当父组件有 `overflow: hidden` 或 `z-index` 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：

> 注意:
>
> 当在使用 portal 时, 记住[管理键盘焦点](https://zh-hans.reactjs.org/docs/accessibility.html#programmatically-managing-focus)就变得尤为重要。
>
> 对于模态对话框，通过遵循 [WAI-ARIA 模态开发实践](https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal)，来确保每个人都能够运用它。

## Fiber架构

**Awesome**

- [React Fiber架构](<https://zhuanlan.zhihu.com/p/37095662>)

** 1. 什么是Fiber架构 **

React v16 启用了全新的架构，叫做Fiber。为了解决大型React项目的性能问题，再顺手解决一些痛点。



## Windowing技术

Windowing 是一种技术，它在任何给定时间只呈现一小部分行，并且可以显著减少重新呈现组件所需的时间以及创建的 DOM 节点的数量。如果应用程序呈现长的数据列表，则建议使用此技术。react-window 和 react-virtualized 都是常用的 windowing 库，它提供了几个可重用的组件，用于显示列表、网格和表格数据。

## refs

> 1. 你什么时候需要使用 refs?
> 2. ref 参数对于所有函数或类组件是否可用?
> 3. 在组件库中当使用 forward refs 时，你需要额外的注意?
> 4. 在 HOCs 中 forward ref 的目的是什么?

*Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。*

在典型的 React 数据流中，[props](https://zh-hans.reactjs.org/docs/components-and-props.html) 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。

**1. 何时使用Refs**

- 管理焦点，文本选择或媒体播放。
- 触发强制动画。
- 集成第三方 DOM 库。

避免使用 refs 来做任何可以通过声明式实现来完成的事情。

**2. 创建Refs**

Refs是通过 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />
  }
}
```

**3. 访问Refs**

当 ref 被传递给 `render`中的元素时，对该节点的引用可以在 ref 的 `current` 属性中被访问

```jsx
const node = this.myRef.current
```

ref 的值根据节点的类型而有所不同：

- 当 `ref` 属性用于 HTML 元素时，构造函数中使用 `React.createRef()` 创建的 `ref` 接收底层 DOM 元素作为其 `current` 属性。
- 当 `ref` 属性用于自定义 class 组件时，`ref` 对象接收组件的挂载实例作为其 `current` 属性。
- **你不能在函数组件上使用 ref 属性**，因为他们没有实例。

React 会在组件挂载时给 `current` 属性传入 DOM 元素，并在组件卸载时传入 `null` 值。`ref`会在 `componentDidMount` 或 `componentDidUpdate` 生命周期钩子触发前更新。

<u>为class组件添加Ref</u>

如果我们想包装上面的 `CustomTextInput`，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 `focusTextInput` 方法：

```jsx
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return (
      <CustomTextInput ref={this.textInput} />
    );
  }
}
```

> 不能在函数组件上使用ref。这是因为函数组件没有实例，但是你可以在函数组件内部的元素上使用ref。

**4. 将DOM Refs暴露给父组件**

在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。

虽然你可以[向子组件添加 ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component)，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数组件上无效。

如果你使用 16.3 或更高版本的 React, 这种情况下我们推荐使用 [ref 转发](https://zh-hans.reactjs.org/docs/forwarding-refs.html)。**Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref**。关于怎样对父组件暴露子组件的 DOM 节点，在 [ref 转发文档](https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components)中有一个详细的例子。

如果你使用 16.2 或更低版本的 React，或者你需要比 ref 转发更高的灵活性，你可以使用[这个替代方案](https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509)将 ref 作为特殊名字的 prop 直接传递。

可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这个方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 [`findDOMNode()`](https://zh-hans.reactjs.org/docs/react-dom.html#finddomnode)，但在[`严格模式`](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage) 下已被废弃且不推荐使用。

**5. 回调 Refs**

React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。

不同于传递 `createRef()` 创建的 `ref` 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。

下面的例子描述了一个通用的范例：使用 `ref` 回调函数，在实例的属性中存储对 DOM 节点的引用。

```javascript
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      // 使用原生 DOM API 使 text 输入框获得焦点
      if (this.textInput) this.textInput.focus();
    };
  }

  componentDidMount() {
    // 组件挂载后，让文本框自动获得焦点
    this.focusTextInput();
  }

  render() {
    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React
    // 实例上（比如 this.textInput）
    return (
      <div>
        <input
          type="text"
          ref={this.setTextInputRef}
        />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

React 将在组件挂载时，会调用 `ref` 回调函数并传入 DOM 元素，当卸载时调用它并传入 `null`。在 `componentDidMount` 或 `componentDidUpdate` 触发前，React 会保证 refs 一定是最新的。

你可以在组件间传递回调形式的 refs，就像你可以传递通过 `React.createRef()` 创建的对象 refs 一样。

```javascript
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />
    </div>
  );
}

class Parent extends React.Component {
  render() {
    return (
      <CustomTextInput
        inputRef={el => this.inputElement = el}
      />
    );
  }
}
```

**6. 什么是 forward refs?**

[React.forwardRef真是个好东西](<https://zhuanlan.zhihu.com/p/37038907>)

> Ref forwarding是一个特性，它允许一些组件获取接收到 ref 对象并将它进一步传递给子组件

```jsx
const ButtonElement = React.forwardRef((props, ref) => {
  <button ref={ref} className="CustomButton">
  	{props.children}
  </button>
})

// Create ref to the DOM button:
const ref = React.createRef();
<ButtonElement ref={ref}>{'Forward Ref'}</ButtonElement>
```

**7. callback refs 和 findDOMNode() **

最好是使用 callback refs 而不是 findDOMNode() API。因为 `findDOMNode()` 阻碍了将来对 React 的某些改进。

使用`findDOMNode`已弃用方案

```jsx
class MyComponent extends Component {
  componentDidMount() {
    findDOMNode(this).scrollIntoView()
  }
  
  render() {
    return <div />
  }
}
```

推荐的方案是

```jsx
class MyComponent extends Component {
  componentDidMount() {
    this.node.scrollIntroView()
  }
  
  render() {
    return <div ref={node => this.node = node} />
  }
}
```

**8. 为什么String Refs被弃用**

如果你以前使用过 React，你可能会熟悉旧的 API，其中的 `ref` 属性是字符串，如 `ref={'textInput'}`，并且 DOM 节点的访问方式为`this.refs.textInput`。我们建议不要这样做，因为字符串引用有以下问题，并且被认为是遗留问题。字符串 refs 在 React v16 版本中被移除。

1. 它们强制 React 跟踪当前执行的组件。这是有问题的，因为它使 React 模块有状态，这会导致在 bundle 中复制 React 模块时会导致奇怪的错误。
2. 它们是不可组合的 - 如果一个库把一个 ref 传给子元素，则用户无法对其设置另一个引用。
3. 它们不能与静态分析工具一起使用，如 Flow。Flow 无法猜测出 `this.refs` 上的字符串引用的作用及其类型。Callback refs 对静态分析更友好。
4. 使用 "render callback" 模式（比如： ），它无法像大多数人预期的那样工作。

```jsx
class MyComponent extends Component {
  renderRow = (index) => {
    // This won't work. Ref will get attached to DataTable rather than MyComponent:
    return <input ref={'input-' + index} />;

    // This would work though! Callback refs are awesome.
    return <input ref={input => this['input-' + index] = input} />;
  }

  render() {
    return <DataTable data={this.props.data} renderRow={this.renderRow} />
  }
}
```



## suspense 组件

如果父组件在渲染时包含dynamic import的模块尚未加载完成，在此加载过程中，你必须使用一个 loading 指示器显示后备内容。这可以使用 Suspense 组件来实现。例如，下面的代码使用 Suspense 组件

```jsx
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading</div>}>
      	<OtherComponent />
      </Suspense>
    </div>
  )
}
```



## loadable 组件

如果你想要在服务端渲染的应用中实现代码拆分，建议使用 Loadable 组件，因为 React.lazy 和 Suspense 还不可用于服务器端渲染。Loadable 允许你将动态导入的组件作为常规的组件进行渲染。让我们举一个例子。

```jsx
import loadable from '@loadable/component'

const OtherComponent = loadable(() => import('./OtherComponent'))

function MyComponent() {
  return {
    <div>
    	<OtherComponent />
    </div>
  }
}
```

现在，其他组件将以单独的包进行加载。