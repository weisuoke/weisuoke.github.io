# React必知必会

## React 组件

> 1. 组件的种类
> 2. 组件和元素有什么区别

**组件的种类 **

*1.1`React.createClass()`*

```jsx
var Greeting = React.createClass({
  render: function() {
    return <h1>Hello, {this.props.name}</h1>
  }
})
```
*1.2 ES6 class*

```jsx
class Greeting extends React.Component {
  render: function() {
    return <h1>Hello, {this.props.name}</h1>
  }
}
```
1.3 无状态函数

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}</h1>
}
```

*1.4 PureComponent*

> 在 Pure Component 中使用渲染属性会有什么问题?



**元素与组件的区别**

组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。

## 组件通信

- [React组件之间的通信](<https://github.com/sunyongjian/blog/issues/27>)

> React组件通信的方式
>
> 1. 父子组件 父->子 prop 子->父 callback
> 2. 兄弟组件 上层Container
> 3. 爷孙组件 context API
> 4. 任意组件 发布订阅模式 
> 5. 状态管理工具 Redux/Mobx




## React的生命周期

![](https://img.ctolib.com/uploadImg/20180613/20180613205737_393.jpg)

> React 生命周期钩子
>
> - componentWillMount()
> - componentDidMount()
> - componentWillReceiveProps()
> - shouldComponentUpdate()
> - componentWillUpdate()
> - componentDidUpdate()
> - componentWillUnmount()

**生命周期的各个阶段**

挂载阶段
1. constructor()
2. componentWillMount()
3. render()
4. componentDidMount()

更新阶段 - 父组件更新 (New props)
1. componentWillReceiveProps()
2. shouldComponentUpdate()
3. componentWillUpdate()
4. render()
5. componentDidUpdate()

更新阶段 - setState()
1. shouldComponentUpdate()
2. componentWillUpdate()
3. render()
4. componentDidUpdate()

更新阶段 - forceUpdate 强制更新
1. componentWillUpdate()
2. render()
3. componentDidUpdate()

卸载阶段
1. componentWillUnmount()

**React Fiber后生命周期的变更**


> 疑问：
>
> React Fiber是什么？
>
> React v16.3以后的生命周期。


## 事件绑定

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true }
    
    // 为了在回调中使用 `this`, 这个绑定时必不可少的
    this.handleClick = this.handleClick.bind(this)
  }
  
  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }
  
  render() {
    return (
    	<button onClick={this.handleClick}>
    		{this.state.isToggleOn ? 'ON' : 'OFF'}
    	</button>
    )
  }
}
```



```jsx
class LoggingButton extends React.Component {
  // 这个语法确保 `this` 绑定在 handleClick 中。
  // 警告：这是 *实验性的* 语法。
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```



```jsx
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      <button onClick={(e) => this.handleClick(e)}>
        Click me
      </button>
    );
  }
}
```



> 三种事件绑定的方式区别，优缺点。



## setState

> Q&A
>
> 1. setState是同步的还是异步的
> 2. 什么场景是异步的，可不可能同步，什么场景下又是同步的
> 3. setState被调用后更新组件的过程？

**0. Awesome**

- [你真的理解setState吗？](<https://zhuanlan.zhihu.com/p/39512941>)
- [揭秘React setState](<https://juejin.im/post/5b87d14e6fb9a01a18268caf>)

**1. 什么是setState?**

setState是react里面一个重要的方法，更新状态`state`使用。

**结论**

> 1. `setState` 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。
> 2. `setState` 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 `setState(partialState, callback)` 中的callback拿到更新后的结果。
> 3. `setState` 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。



## JSX

## Hooks

React v16.8 提出来的一个概念。

**Awesome**

- [react-hanger]()

** 1. 什么是Hooks **

> 我的理解是
>
> 提供一些API在Function Components中使用state等

** 2. Hooks产生的背景 **

React世界中，有容器组件和UI组件之分，在React Hooks出现之前，UI组件我们可以使用函数，无状态组件来展示UI，而对于容器组件，函数组件就显得无能为力，我们依赖类组件来获取数据，处理数据，并向下传递给UI组件进行渲染。

** 3. 使用方式 **

*3.1 useState 保存组件状态*

```jsx
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

function App() {
  const [obj, setObject] = useState({
    count: 0,
    name: "alife"
  });
  return (
    <div className="App">
      Count: { obj.count }
      <button onClick={() =>setObject({...obj, count: obj.count + 1})}>+</button>
      <button onClick={() =>setObject({...obj, count: obj.count - 1})}>-</button>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

*3.2 useEffect 处理副作用*

> Q & A 
>
> 1. Hooks之前怎么处理副作用的。
> 2. 什么是副作用？

* 3.3 useContext 减少组件层级*

> Q & A
>
> 1. React中的组件通信是怎样进行的
> 2. Context API是什么？
> 3. useContext 与 Context API 的区别是什么？
> 4. 设计上你会去怎么设计。



## 高阶组件(HOC)

> Q & A
>
> 1. 什么是高阶组件？
>
> 2. 为什么要设计高阶组件？
>
> 3. 高阶组件解决了什么具体的问题？
>
> 4. 如何使用渲染属性创建 HOC?
> 
> 5. HOC 有哪些限制?
> 
> 6. 什么是 HOC 工厂实现?

**0. 参考阅读**

> - [React 中的高阶组件及其应用场景](<https://juejin.im/post/5c72b97de51d4545c66f75d5>)

**1. 什么是高阶组件**

> 高阶函数：如果一个函数 **接受一个或多个函数作为参数或者返回一个函数** 就可称之为 **高阶函数**。

```javascript
// 一个简单的高阶函数
function withGreeting(greeting = () => {}) {
    return greeting;
}
```

高阶组件的定义和高阶函数非常相似

> 如果一个函数 **接受一个或多个组件作为参数并且返回一个组件** 就可称之为 **高阶组件**。

```java
function HigherOrderComponent(WrappedComponent) {
    return <WrappedComponent />;
}
```



## render props

## Reconciliation

## Context API

> 在使用 context 时，如何解决性能方面的问题?
> 你是怎么使用 contextType
> 在 context 中默认值的目的是什么?
> 举例说明如何使用 context?

## 错误边界

## 受控组件和非受控组件

> 什么是受控组件和非受控组件？
>
> 两者的区别，什么场景下使用。
>
> 如何设置非受控组件的默认值

**1. 受控组件**

> 在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 [`setState()`](https://zh-hans.reactjs.org/docs/react-component.html#setstate)来更新。
>
> 我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

由于在表单元素上设置了 `value` 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。由于 `handlechange` 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

对于受控组件来说，每个 state 突变都有一个相关的处理函数。这使得修改或验证用户输入变得简单。例如，如果我们要强制要求所有名称都用大写字母书写，我们可以将 `handlechange` 改写为：

```jsx
handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
```

**2. 非受控组件**

> 在大多数情况下，我们推荐使用 [受控组件](https://zh-hans.reactjs.org/docs/forms.html) 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。

要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 [使用 ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html) 来从 DOM 节点中获取表单数据。

例如，下面的代码使用非受控组件接受一个表单的值：

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

**3 非受控组件默认值**

在 React 渲染生命周期时，表单元素上的 `value` 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 `defaultValue` 属性，而不是 `value`。

```jsx
render() {
  return (
    <form onSubmit={this.handleSubmit}>
      <label>
        Name:
        <input
          defaultValue="Bob"
          type="text"
          ref={this.input} />
      </label>
      <input type="submit" value="Submit" />
    </form>
  );
}
```

同样，`<input type="checkbox">` 和 `<input type="radio">` 支持 `defaultChecked`，`<select>` 和 `<textarea>` 支持 `defaultValue`。

## Portals

> - Portals 是什么？
> - portals 的典型使用场景是什么?

**1. Portals是什么?**

> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

```jsx
ReactDOM.createPortal(child, container)
```

第一个参数（`child`）是任何[可渲染的 React 子元素](https://zh-hans.reactjs.org/docs/react-component.html#render)，例如一个元素，字符串或 fragment。第二个参数（`container`）是一个 DOM 元素。

**2. 用法**

通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：

```jsx
render() {
  // React 挂载了一个新的 div，并且把子元素渲染其中
  return (
    <div>
      {this.props.children}
    </div>
  );
}
```

然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的：

```jsx
render() {
  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个可以在任何位置的有效 DOM 节点。
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```

一个 portal 的典型用例是当父组件有 `overflow: hidden` 或 `z-index` 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：

> 注意:
>
> 当在使用 portal 时, 记住[管理键盘焦点](https://zh-hans.reactjs.org/docs/accessibility.html#programmatically-managing-focus)就变得尤为重要。
>
> 对于模态对话框，通过遵循 [WAI-ARIA 模态开发实践](https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal)，来确保每个人都能够运用它。

## Fiber架构

**Awesome**

- [React Fiber架构](<https://zhuanlan.zhihu.com/p/37095662>)

** 1. 什么是Fiber架构 **

React v16 启用了全新的架构，叫做Fiber。为了解决大型React项目的性能问题，再顺手解决一些痛点。



## Windowing技术

## refs

> 你什么时候需要使用 refs?
> ref 参数对于所有函数或类组件是否可用?
> 在组件库中当使用 forward refs 时，你需要额外的注意?
> 在 HOCs 中 forward ref 的目的是什么?
> 

## suspense 组件

## loadable 组件